# Ответы на вопросы по тестированию

## 1. В чём основное различие между unittest и pytest?
unittest — это встроенная библиотека Python, основанная на объектно-ориентированной модели. Тесты создаются в классах, унаследованных от unittest.TestCase, и представляют собой отдельные методы, начинающиеся с test_.

pytest — это внешний фреймворк, позволяющий создавать тесты в виде обыкновенных функций. Код становится компактнее и легче читаемым. Поддерживает динамическую генерацию тестов, расширенную обработку исключений и возможность легкой интеграции внешних модулей и плагины.

## 2. Почему важно использовать автоматические тесты при разработке?
Автоматические тесты необходимы для того, чтобы:

- Минимизировать риски появления новых багов при изменениях кода.
- Ускорить выявление ошибок ещё на этапе разработки.
- Предоставить документацию по ожидаемому поведению приложения.
- Улучшить качество кода и упростить его дальнейшее сопровождение.
- Экономия времени разработчиков и повышение продуктивности.

## 3. Какие есть виды ассертов в unittest и pytest?
# В unittest:
- assertEqual(a, b) — проверка равенства.
- assertNotEqual(a, b) — проверка неравенства.
- assertTrue(x) / assertFalse(x) — проверка булевого условия.
- assertIs(a, b) / assertIsNot(a, b) — проверка объекта на идентичность.
- assertIn(a, b) / assertNotIn(a, b) — проверка наличия элемента в коллекции.
- assertRaises(exc_type, callable, args) — проверка возникновения исключения.
  
  Unittest предоставляет специализированные методы для проверок и строго структурированную организацию тестов, встроенную в Python.
  
# В pytest:
Ассерты представлены обычными выражениями Python с оператором assert:
- assert expression — проверяет произвольное выражение на истину.
- with pytest.raises(exception_type) — специальный механизм для проверки того, что в ходе выполнения блока кода произойдёт указанное исключение.
  
  Pytest предоставляет удобное представление ошибок и подсветку разницы между фактическими и ожидаемыми значениями.

## 4. Что делает @pytest.mark.parametrize?
Декоратор @pytest.mark.parametrize позволяет многократно вызывать один и тот же тест с различными параметрами, передавая разные данные. Благодаря этому достигается экономия времени и сокращение дублирующего кода.

- Пример использования:
```
import pytest

@pytest.mark.parametrize(
    'input_data, expected',
    [(1, 2), (-1, 0)]
)
def test_function(input_data, expected):
    result = my_function(input_data)
    assert result == expected
```

## 5. В каких случаях вы бы предпочли использовать pytest вместо unittest?
 Выбор пал бы на pytest в ситуациях, когда:

- Необходимо повысить скорость и эффективность разработки тестов.
- Нужно сократить избыточный код и уменьшить сложность тестов.
- Потребуется удобная параметризация тестов.
- Планируется интеграция с CI-системами и расширение функциональности через плагины.
- Есть потребность в улучшенном механизме обработки ошибок и отображении результатов тестов.
